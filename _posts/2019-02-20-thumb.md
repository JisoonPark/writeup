---
layout: post
title: thumb
category: Reversing
rpath: /resource/thumb
tag: [] 
---

**Category:** Reversing

**Source:** Samsung CTF 2017 Final

**Points:** 200

**Author:** Kuenhwan Kwak(kh243.kwak)

**Description:** 

>주어진 바이너리에서 Password를 획득하시요.

## Write-up

main.bin 파일은 elf도 pe 파일도 아니며 단지 바이너리 파일 덩어리이다. <br>
분석에 앞서서 xxd hexdump를 확인해보면 ARM 명령어임을 알 수 있다. <br>

![disassem](./resource/disassemble.png)

따라서 main.bin은 어떤 ARM 용 Firmware임을 알수 있다.  <br>
하지만 정확히 어떤 주소에 올려서 어떤 장치에 올려서 실행해야 하는지는 아직 알수 없다. <br>
<br>

0x0 번 부터 따라가 보면, 금방 0x10565라는 주소로 Longjump 하는 것을 알 수있다. <br>
홀수 주소 0x10565로 Branch 하는 것을 보아 Thumb 모드로 빌드된 Binary이며 <br>
Binary 사이즈가 0x1000 이내인 점을 볼때 적절한 Loading 주소는 0x10000 임을 알 수 있다.<br>
T32 Simulator로 제대로된 주소로 로딩해서 다시 시작해본다. <br>

```
d.load.binary X:\main.bin 0x10000 
r.s pc 0x10000
```

실행 시켜 보면 복잡한 수행을 하다가 0x101f1000 주소의 값을 읽어서, <br>
0x40의 Bit가 Set되었는지 확인하고 아니라면 다시 읽는 부분이 있다.<br>
0x101f1000 에 Write Break Point를 걸고 확인하면 해당 Bit를 직접 Setting하는 코드는 없지만<br>
좀더 앞에 한글자씩 입력하는 Code가 있다 'p','a','s','s','w'..."<br>

따라서 0x101f1000 주소는 UART IO Address이며, UART에서 'password:'를 입력한 후 <br>
사용자의 입력을 기다리는 중임을 알 수 있다.<br>
<br>
Google에 '0x101f1000 uart arm' 검색을 통해서 Firmware가 실행될 환경은 <br>
ARM에서 제공하는 Versatile Platform이고 QEMU를 통해서 실행 할수 있다.<br>
해당 바이너리를 실행하는 코드는 다음과 같다.<br>
```
$qemu-system-arm -M versatilepb -m 128M -nographic -kernel main.bin
password: 
```
아무 글자나 입력하면 'wrong'을 출력하고 무한루프에 빠진다.<br>
따라서 정확한 Password를 입력하면 다른 출력을 하게 되고 그 값이 flag일 것 이다. <br>
<br>
0x10565로 Jump하고 Return을 하지 않고 계속 BL을 하는 것을 보아 해당 코드가 main() 이고 <br>
상단에서 for문을 1000번씩 4번 돌고, 16x16 배열 2개를 비교하면서<br>
1개라도 다르면 "Wrong" 이 출력되고, 256개 값이 모두 같다면 "yes!"가 출력 되는 것을 알수 있다.<br>
보면 0x11300의 2차원 배열은 입력으로 사용한 후에 조작이 되고, 0x10838 배열은 바이너리에<br>
포함이 되어 있으며 변경 되지 않는 것을 알 수있다. 따라서 원하는 답은 0x10838에 포함되어 있다.<br>
<br>
Dissassemble 된 코드만으로는 분석이 쉽지 않다. 완벽하진 않더라도 Decompiler과정이 필요하다. <br>
<https://retdec.com/>를 이용해서 함수 하나 하나를 분석해 본다<br>
```
void function_10070(void) {
    // 0x10070
    // branch -> 0x1007e
    while (*(int32_t *)0x101f1018 != 0) {
        // 0x1007e
        // continue -> 0x1007e
    }
    // 0x1008a
    *(int32_t *)0x101f1000 = g1 % 256;
    abort();
    // UNREACHABLE
}
```
이건 Uart Out과 같다. 화면에 한글자씩 출력한다.
<br><br>

```
void function_100a4(void) {
    // 0x100a4
    // branch -> 0x100aa
    while (*(int32_t *)0x101f1018 == 64) {
        // 0x100aa
        // continue -> 0x100aa
    }
    // 0x100b6
    g1 = *(int32_t *)0x101f1000 % 256;
    abort();
    // UNREACHABLE
}
```
이건 Uart getchar와 같다 사용자 입력을 한글자씩 입력받는다
<br><br>

```
void function_102e8(void) {
    int32_t v1;

    // branch -> 0x102f4
    for (int32_t i = 0; i < 34; i++) {
        // 0x102f4
        c = function_100a4();
        v3 = function_10200();
        v4 = function_10200();
        v3 = v3 & 0xf ;
        v4 = v4 & 0xf ;
        char * v5 = (char *)a[v3][v4];
        a[v3][v4] = v5^c;		
        // continue -> 0x102f4
    }
    // 0x10352
    abort();
    // UNREACHABLE
}
```
이건 한글 자씩 입력받은 값을 16x16 배열에 저장하는 코드와 같다.<br>
다만 Index를 받아올때 0x10200 에 있는 함수를 실행해서 Index를 받아 온다.
<br>
```
void function_10200(void) {
    int32_t v1 = g5; // 0x10200
    int32_t v2;
    g5 = &v2;
    uint16_t v3 = *(int16_t *)0x112f8; // 0x10208
    int16_t v4;
    if (v3 >= 625) {
        // 0x10216
        function_10160();
        v4 = *(int16_t *)0x112f8;
        // branch -> 0x10220
    } else {
        v4 = v3;
    }
    int32_t * v5 = (int32_t *)(4 * (int32_t)v4 + 0x10938); // 0x10226_0
    int32_t v6 = *v5; // 0x10226
    v2 = v6;
    *(int16_t *)0x112f8 = v4 + 1;
    int32_t v7 = *v5 / 2048 ^ v6; // 0x10246
    int32_t v8 = 128 * v7 & 0x9D2C5680 ^ v7; // 0x10254
    uint32_t v9 = 0x8000 * v8 & 0xefc60000 ^ v8; // 0x10262
    int32_t v10 = v9 / 0x40000 ^ v9; // 0x1026c
    v2 = v10;
    g1 = v10;
    g5 = v1;
    abort();
    // UNREACHABLE
}
```
이 함수는 뭔가 복잡한 연산을 하는 것을 알 수있다. <br>
Return 되는 값이 들어가 있는 R0 레지스터 역시 <br>
0x92aa1674, 0x8ca45cd9, 0xd0b09f67 .. 으로 <br>
어떤 규칙성을 가지고 Return 되는 것 같지 않다. 
다만 연산 마지막에 0x9d2c5680, 0xefc60000 상수를 가지고 Bit 연산을 하는 것을 알 수 있다. <br>
당연히 Address도 아니고, Io 주소라고 보기도 힘들다. <br>
저 상수에 어떤 의미가 있는지 검색해보면 <br>
mt19937의 Reference 코드가 많이 출력된다. <br>

<http://www.acclab.helsinki.fi/~knordlun/mc/mt19937.c/> <br>
<http://www.cplusplus.com/reference/random/mt19937/> <br>

MT 19937은 메르센 트위스터로 불리는 PRNG 방법이며, <br>
동일한 Seed 값을 가지고 시작하면 다음의 Random값도 예측가능한 특성이 있다고 한다. <br>
<https://ko.wikipedia.org/wiki/%EB%A9%94%EB%A5%B4%EC%84%BC_%ED%8A%B8%EC%9C%84%EC%8A%A4%ED%84%B0/><br>
<br>
예제 코드는 아래와 같다.
<br>
```
#define N 624
#define M 397
#define MATRIX_A 0x9908b0df   /* constant vector a */
#define UPPER_MASK 0x80000000 /* most significant w-r bits */
#define LOWER_MASK 0x7fffffff /* least significant r bits */

/* Tempering parameters */
#define TEMPERING_MASK_B 0x9d2c5680
#define TEMPERING_MASK_C 0xefc60000
#define TEMPERING_SHIFT_U(y)  (y >> 11)
#define TEMPERING_SHIFT_S(y)  (y << 7)
#define TEMPERING_SHIFT_T(y)  (y << 15)
#define TEMPERING_SHIFT_L(y)  (y >> 18)

unsigned long mt_rand()
{
    unsigned long y;
    static unsigned long mag01[2]={0x0, MATRIX_A};
    /* mag01[x] = x * MATRIX_A  for x=0,1 */

    if (mti >= N) { /* generate N words at one time */
        int kk;

        if (mti == N+1)   /* if sgenrand() has not been called, */
            init_seed(SEED); /* a default initial seed is used   */

        for (kk=0;kk<N-M;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];
        }
        for (;kk<N-1;kk++) {
            y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);
            mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];
        }
        y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);
        mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];

        mti = 0;
    }

    y = mt[mti++];
    y ^= TEMPERING_SHIFT_U(y);
    y ^= TEMPERING_SHIFT_S(y) & TEMPERING_MASK_B;
    y ^= TEMPERING_SHIFT_T(y) & TEMPERING_MASK_C;
    y ^= TEMPERING_SHIFT_L(y);

    return y;
}
```
mt_rand() 함수가 function_10200와 거의 유사한 것으로 보아 <br>
main.bin에서는 이 메르센 트위스터를 활용하는 code 임을 알 수 있다. <br>
<br>
위 정보까지 파악해서 보면 main()의 동작은 다음 과 같다. <br>
<br>

```
void input_string(void)
{
    char c;
    int i;
    unsigned char a;
    unsigned char b;


    for(i = 0 ; i < 34 ; i++)
    {
        c = getchar();
        a = (mt_rand()&0xF);
        b = (mt_rand()&0xF);
        map[a][b] = (unsigned char)(map[a][b]^c);
    }
}

void init_map(void)
{
    int i, j;
    unsigned char val;
    unsigned long rand;

    for(i = 0 ; i < 16 ; i++)
    {
        for(j = 0 ; j < 16 ; j++)
        {
            rand = mt_rand();
            val = (unsigned char)rand;
            map[i][j] = val;
        }
    }
}

void swap1(int a, int b)
{
    unsigned char tmp;
    int i;

    for(i = 0 ; i < 16 ; i++)
    {
        tmp = map[i][a];
        map[i][a] = map[i][b];
        map[i][b] = tmp;
    }
}

void rshift(int a, char b)
{
    int i;
    unsigned char right = 0;
    unsigned char left;

    right = 0;
    for(i =0 ; i < 16 ; i++)
    {
        left = (uint8_t)(map[a][i]&((1<<b)-1))<<(8-b);
        map[a][i] = right | (map[a][i] >> b);
        right = left;

    }
    map[a][0] |= right;
}

void eor(int a, int b, uint32_t c)
{
    int i;

    for(i = 0 ; i < 16 ; i++)
    {
        map[i][b] = (unsigned char)map[i][b]^c;
        map[a][i] = (unsigned char)map[a][i]^c;
    }
}

void swap2(int a, int b)
{
    unsigned char tmp;
    int i;

    for(i = 0 ; i < 16 ; i++)
    {
        tmp = map[a][i];
        map[a][i] = map[b][i];
        map[b][i] = tmp;
    }
}



int main(void)
{
    int i, j, k, l;
    int cnt;
    int c;

    init_seed(0xC0FFEE);

    init_map();

    input_string("password:");

    for(i = 0 ; i < 1000 ; i++)
    {
        int a;
        int b;
        a = mt_rand()&0xF;
        b = mt_rand()&0xF;
        swap2(a, b);
    }


    for(j = 0 ; j < 1000 ; j++)
    {
        int a;
        char b;

        a = mt_rand()&0xF;
        b = mt_rand()&0x7;
        rshift(a, b);
    }

    for(k = 0 ; k < 1000 ; k++)
    {
        int a;
        int b;
        uint32_t c;

        a = mt_rand()&0xF;
        b = mt_rand()&0xF;
        c = mt_rand();
        eor(a, b, c);
    }

    for(l = 0 ; l < 1000 ; l++)
    {
        int a;
        int b;
        a = mt_rand()&0xF;
        b = mt_rand()&0xF;
        swap1(a, b);
    }

    cnt = 0;
    for(i = 0 ; i < 16 ; i++)
    {
        for(j = 0 ; j < 16 ; j++)
        {
            if(map[i][j] != final[i][j])
                uart_out('w');
				uart_out('r');
				uart_out('o');
				uart_out('n');
				uart_out('g');
				asm ("b .");
        }
    }
	uart_out('y');
	uart_out('e');
	uart_out('s');
	uart_out('!');
	asm ("b .");
}
```
mt19937방법이고 SEED 값은 0xc0ffee 임을 알수 있다 <br>
입력 받은 문자 33개의 문자는 map[][]에 eor을 해서 저장을 하고 <br>
1000번 씩 loop를 돌면서 swap2, rshift, eor, swap2의 동작을 한다. <br>
<br>
해당 입력이 final배열(0x10838)과 완전 동일하면 yes!를 출력하는 것을 알 수 있다. <br>
그리고 MT19937 특성상 SEED가 동일하면, Random넘버가 완전 동일한 순서로 <br>
나오게 됨으로 어떤 배열에 값이 저장되고 swap이 되는지 등도 마찬가지로 예측이 가능하다. <br>
<br>
문제를 해결하는 방법은 BruteForce로 한글자씩 맞춰본 후에 Final 배열과 매치가 하나라도 더 되면 <br>
다음 문자를 맞추는 식으로 하면 33(문자열길이)*95(가능한 아스키 코드)만에 답을 알 수 있다. <br>
<br>
C코드로 final[] 배열을 미리 입력하고 main.bin을 하는 동작을 따라하고 <br>
마지막에 가장 많이 Match가 된 문자를 선택하고 다음 문자를 다시 검사하는 코드를 만든다<br>

![Source](./resource/answer.c)

```
$./answer
SCTF{AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
SCTF{tAAAAAAAAAAAAAAAAAAAAAAAAAAAA
SCTF{t1AAAAAAAAAAAAAAAAAAAAAAAAAAA
SCTF{t1JAAAAAAAAAAAAAAAAAAAAAAAAAA
SCTF{t1JyAAAAAAAAAAAAAAAAAAAAAAAAA
SCTF{t1Jy_AAAAAAAAAAAAAAAAAAAAAAAA
SCTF{t1Jy_tAAAAAAAAAAAAAAAAAAAAAAA
SCTF{t1Jy_tIAAAAAAAAAAAAAAAAAAAAAA
SCTF{t1Jy_tInAAAAAAAAAAAAAAAAAAAAA
SCTF{t1Jy_tInyAAAAAAAAAAAAAAAAAAAA
SCTF{t1Jy_tIny_AAAAAAAAAAAAAAAAAAA
SCTF{t1Jy_tIny_bAAAAAAAAAAAAAAAAAA
SCTF{t1Jy_tIny_baAAAAAAAAAAAAAAAAA
SCTF{t1Jy_tIny_barAAAAAAAAAAAAAAAA
SCTF{t1Jy_tIny_bareAAAAAAAAAAAAAAA
SCTF{t1Jy_tIny_baremAAAAAAAAAAAAAA
SCTF{t1Jy_tIny_baremeAAAAAAAAAAAAA
SCTF{t1Jy_tIny_baremetAAAAAAAAAAAA
SCTF{t1Jy_tIny_baremetaAAAAAAAAAAA
SCTF{t1Jy_tIny_baremetalAAAAAAAAAA
SCTF{t1Jy_tIny_baremetal_AAAAAAAAA
SCTF{t1Jy_tIny_baremetal_fAAAAAAAA
SCTF{t1Jy_tIny_baremetal_fiAAAAAAA
SCTF{t1Jy_tIny_baremetal_firAAAAAA
SCTF{t1Jy_tIny_baremetal_firmAAAAA
SCTF{t1Jy_tIny_baremetal_firmwAAAA
SCTF{t1Jy_tIny_baremetal_firmwaAAA
SCTF{t1Jy_tIny_baremetal_firmwarAA
SCTF{t1Jy_tIny_baremetal_firmwarAA
SCTF{t1Jy_tIny_baremetal_firmwarA}
```

마지막으로 출력된 문자열 'SCTF{t1Jy_tIny_baremetal_firmwarA}'  <br>
을 qemu로 실행해면 'yes!'가 출력 되는 것을 알 수 있다.<br>

```
$ qemu-system-arm -M versatilepb -m 128M -nographic -kernel main.bin
password: yes!
```

하지만 약간 실제 CTF 사이트에서 정답이 아닌 것으로 나오는데 <br>
좀더 파보면 tiJy의 'J'와 firmwareA의 'A'가 조합이 가능해서<br>
실제로 좀더 여러가지 정답이 가능 한 것을 알수 있다.<br>
아래 문자열들은 모두 답이 될 수 있다.<br>

```
SCTF{t1 y_tIny_baremetal_firmwar+}
SCTF{t1!y_tIny_baremetal_firmwar*}
SCTF{t1"y_tIny_baremetal_firmwar)}
SCTF{t1#y_tIny_baremetal_firmwar(}
SCTF{t1$y_tIny_baremetal_firmwar/}
SCTF{t1%y_tIny_baremetal_firmwar.}
SCTF{t1&y_tIny_baremetal_firmwar-}
SCTF{t1'y_tIny_baremetal_firmwar,}
SCTF{t1(y_tIny_baremetal_firmwar#}
SCTF{t1)y_tIny_baremetal_firmwar"}
SCTF{t1*y_tIny_baremetal_firmwar!}
SCTF{t1+y_tIny_baremetal_firmwar }
SCTF{t1,y_tIny_baremetal_firmwar'}
SCTF{t1-y_tIny_baremetal_firmwar&}
SCTF{t1.y_tIny_baremetal_firmwar%}
SCTF{t1/y_tIny_baremetal_firmwar$}
SCTF{t10y_tIny_baremetal_firmwar;}
SCTF{t11y_tIny_baremetal_firmwar:}
SCTF{t12y_tIny_baremetal_firmwar9}
SCTF{t13y_tIny_baremetal_firmwar8}
SCTF{t14y_tIny_baremetal_firmwar?}
SCTF{t15y_tIny_baremetal_firmwar>}
SCTF{t16y_tIny_baremetal_firmwar=}
SCTF{t17y_tIny_baremetal_firmwar<}
SCTF{t18y_tIny_baremetal_firmwar3}
SCTF{t19y_tIny_baremetal_firmwar2}
SCTF{t1:y_tIny_baremetal_firmwar1}
SCTF{t1;y_tIny_baremetal_firmwar0}
SCTF{t1<y_tIny_baremetal_firmwar7}
SCTF{t1=y_tIny_baremetal_firmwar6}
SCTF{t1>y_tIny_baremetal_firmwar5}
SCTF{t1?y_tIny_baremetal_firmwar4}
SCTF{t1@y_tIny_baremetal_firmwarK}
SCTF{t1Ay_tIny_baremetal_firmwarJ}
SCTF{t1By_tIny_baremetal_firmwarI}
SCTF{t1Cy_tIny_baremetal_firmwarH}
SCTF{t1Dy_tIny_baremetal_firmwarO}
SCTF{t1Ey_tIny_baremetal_firmwarN}
SCTF{t1Fy_tIny_baremetal_firmwarM}
SCTF{t1Gy_tIny_baremetal_firmwarL}
SCTF{t1Hy_tIny_baremetal_firmwarC}
SCTF{t1Iy_tIny_baremetal_firmwarB}
SCTF{t1Jy_tIny_baremetal_firmwarA}
SCTF{t1Ky_tIny_baremetal_firmwar@}
SCTF{t1Ly_tIny_baremetal_firmwarG}
SCTF{t1My_tIny_baremetal_firmwarF}
SCTF{t1Ny_tIny_baremetal_firmwarE}
SCTF{t1Oy_tIny_baremetal_firmwarD}
SCTF{t1Py_tIny_baremetal_firmwar[}
SCTF{t1Qy_tIny_baremetal_firmwarZ}
SCTF{t1Ry_tIny_baremetal_firmwarY}
SCTF{t1Sy_tIny_baremetal_firmwarX}
SCTF{t1Ty_tIny_baremetal_firmwar_}
SCTF{t1Uy_tIny_baremetal_firmwar^}
SCTF{t1Vy_tIny_baremetal_firmwar]}
SCTF{t1Wy_tIny_baremetal_firmwar\}
SCTF{t1Xy_tIny_baremetal_firmwarS}
SCTF{t1Yy_tIny_baremetal_firmwarR}
SCTF{t1Zy_tIny_baremetal_firmwarQ}
SCTF{t1[y_tIny_baremetal_firmwarP}
SCTF{t1\y_tIny_baremetal_firmwarW}
SCTF{t1]y_tIny_baremetal_firmwarV}
SCTF{t1^y_tIny_baremetal_firmwarU}
SCTF{t1_y_tIny_baremetal_firmwarT}
SCTF{t1`y_tIny_baremetal_firmwark}
SCTF{t1ay_tIny_baremetal_firmwarj}
SCTF{t1by_tIny_baremetal_firmwari}
SCTF{t1cy_tIny_baremetal_firmwarh}
SCTF{t1dy_tIny_baremetal_firmwaro}
SCTF{t1ey_tIny_baremetal_firmwarn}
SCTF{t1fy_tIny_baremetal_firmwarm}
SCTF{t1gy_tIny_baremetal_firmwarl}
SCTF{t1hy_tIny_baremetal_firmwarc}
SCTF{t1iy_tIny_baremetal_firmwarb}
SCTF{t1jy_tIny_baremetal_firmwara}
SCTF{t1ky_tIny_baremetal_firmwar`}
SCTF{t1ly_tIny_baremetal_firmwarg}
SCTF{t1my_tIny_baremetal_firmwarf}
SCTF{t1ny_tIny_baremetal_firmware}
SCTF{t1oy_tIny_baremetal_firmward}
SCTF{t1py_tIny_baremetal_firmwar{}
SCTF{t1qy_tIny_baremetal_firmwarz}
SCTF{t1ry_tIny_baremetal_firmwary}
SCTF{t1sy_tIny_baremetal_firmwarx}
SCTF{t1uy_tIny_baremetal_firmwar~}
SCTF{t1vy_tIny_baremetal_firmwar}}
SCTF{t1wy_tIny_baremetal_firmwar|}
SCTF{t1xy_tIny_baremetal_firmwars}
SCTF{t1yy_tIny_baremetal_firmwarr}
SCTF{t1zy_tIny_baremetal_firmwarq}
SCTF{t1{y_tIny_baremetal_firmwarp}
SCTF{t1|y_tIny_baremetal_firmwarw}
SCTF{t1}y_tIny_baremetal_firmwarv}
SCTF{t1~y_tIny_baremetal_firmwaru}
SCTF{t1ny_tIny_baremetal_firmware}
```

실제 Flag는 다음과 같다.<br>

Flag : <b>SCTF{t1ny_tIny_baremetal_firmware}</b>
